#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processFileData = exports.s2tsVersion = void 0;
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const chokidar_1 = __importDefault(require("chokidar"));
const version_1 = require("./compiler/version");
const transpile_1 = require("./compiler/transpile");
const rollup_1 = require("./compiler/rollup");
const log_1 = require("./log");
exports.s2tsVersion = "0.6.1";
const sourcePathPart = "/content/csgo_addons";
const start = (specifiedPath) => {
    const projectDir = standardisePath(specifiedPath ?? process.cwd());
    const watchDir = standardisePath(node_path_1.default.join(projectDir, "./scripts/vscripts"));
    if (!watchDir.includes(sourcePathPart)) {
        log_1.logger.error(`The current path '${watchDir}' was expected to contain '${sourcePathPart}' but it did not. Check if you are running in the correct folder.`);
        return;
    }
    if (!(0, node_fs_1.existsSync)(watchDir)) {
        (0, node_fs_1.mkdirSync)(watchDir);
    }
    chokidar_1.default
        .watch(watchDir, { persistent: true })
        .on("add", filePath => processFileAtPath({ project: projectDir, file: filePath }))
        .on("change", filePath => processFileAtPath({ project: projectDir, file: filePath }))
        .on("error", error => log_1.logger.error(`Watcher error: ${error}`));
    log_1.logger.info(`Watching for file changes in ${watchDir}`);
};
const processFileAtPath = async (pathFor) => {
    if (!pathFor.file.endsWith(".vts") && !pathFor.file.endsWith(".ts")) {
        return;
    }
    if (pathFor.file.endsWith(".d.ts")) {
        return;
    }
    const standardFilePath = standardisePath(pathFor.file);
    try {
        const compiledBuffer = await (0, exports.processFileData)(pathFor.project, {
            name: node_path_1.default.basename(standardFilePath),
            path: standardFilePath,
            content: (0, node_fs_1.readFileSync)(standardFilePath).toString("utf-8")
        });
        if (!compiledBuffer) {
            return;
        }
        const outputFilePath = standardFilePath.replace(".vts", ".js").replace(".ts", ".js").replace("/scripts/vscripts/", "/scripts/vscripts/build/");
        (0, node_fs_1.mkdirSync)(node_path_1.default.dirname(outputFilePath), { recursive: true });
        (0, node_fs_1.writeFileSync)(outputFilePath, new Uint8Array(compiledBuffer));
        log_1.logger.info(`Compiled: ${node_path_1.default.basename(outputFilePath)}`);
    }
    catch (error) {
        log_1.logger.error(`Unhandled error in s2ts: ${error}`);
    }
};
const processFileData = async (pathForProject, file) => {
    const transpiledResult = (0, transpile_1.transpileFromTypeScript)(file);
    if (!transpiledResult.success)
        return;
    const bundledData = await (0, rollup_1.bundleImports)(pathForProject, { ...file, content: transpiledResult.output });
    return Buffer.from((0, version_1.addS2tsVersion)(bundledData.code));
};
exports.processFileData = processFileData;
const standardisePath = (fullPath) => fullPath.replace(/[\\/]+/g, "/");
const command = process.argv[2];
const argument = process.argv[3];
switch (command) {
    case "dev":
    case "start":
        start(argument);
        break;
    default:
        console.log(`Unknown command: ${command}. Did you mean 'start'?`);
        break;
}
